// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.3
// source: proto/voice.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TextToSpeechServiceClient is the client API for TextToSpeechService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TextToSpeechServiceClient interface {
	// Simple: Text in, Audio out
	ConvertTextToSpeech(ctx context.Context, in *TextToSpeechRequest, opts ...grpc.CallOption) (*TextToSpeechResponse, error)
	// Stream response: Long text in, stream of audio chunks out
	StreamTextToSpeech(ctx context.Context, in *TextToSpeechRequest, opts ...grpc.CallOption) (TextToSpeechService_StreamTextToSpeechClient, error)
	// Stream request: Stream of text chunks in, complete audio out
	StreamTextToSpeechRequest(ctx context.Context, opts ...grpc.CallOption) (TextToSpeechService_StreamTextToSpeechRequestClient, error)
	// Bidirectional: Stream of text chunks in, stream of audio chunks out
	StreamTextToSpeechBidirectional(ctx context.Context, opts ...grpc.CallOption) (TextToSpeechService_StreamTextToSpeechBidirectionalClient, error)
}

type textToSpeechServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTextToSpeechServiceClient(cc grpc.ClientConnInterface) TextToSpeechServiceClient {
	return &textToSpeechServiceClient{cc}
}

func (c *textToSpeechServiceClient) ConvertTextToSpeech(ctx context.Context, in *TextToSpeechRequest, opts ...grpc.CallOption) (*TextToSpeechResponse, error) {
	out := new(TextToSpeechResponse)
	err := c.cc.Invoke(ctx, "/voice.TextToSpeechService/ConvertTextToSpeech", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *textToSpeechServiceClient) StreamTextToSpeech(ctx context.Context, in *TextToSpeechRequest, opts ...grpc.CallOption) (TextToSpeechService_StreamTextToSpeechClient, error) {
	stream, err := c.cc.NewStream(ctx, &TextToSpeechService_ServiceDesc.Streams[0], "/voice.TextToSpeechService/StreamTextToSpeech", opts...)
	if err != nil {
		return nil, err
	}
	x := &textToSpeechServiceStreamTextToSpeechClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TextToSpeechService_StreamTextToSpeechClient interface {
	Recv() (*AudioChunk, error)
	grpc.ClientStream
}

type textToSpeechServiceStreamTextToSpeechClient struct {
	grpc.ClientStream
}

func (x *textToSpeechServiceStreamTextToSpeechClient) Recv() (*AudioChunk, error) {
	m := new(AudioChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *textToSpeechServiceClient) StreamTextToSpeechRequest(ctx context.Context, opts ...grpc.CallOption) (TextToSpeechService_StreamTextToSpeechRequestClient, error) {
	stream, err := c.cc.NewStream(ctx, &TextToSpeechService_ServiceDesc.Streams[1], "/voice.TextToSpeechService/StreamTextToSpeechRequest", opts...)
	if err != nil {
		return nil, err
	}
	x := &textToSpeechServiceStreamTextToSpeechRequestClient{stream}
	return x, nil
}

type TextToSpeechService_StreamTextToSpeechRequestClient interface {
	Send(*TextChunk) error
	CloseAndRecv() (*TextToSpeechResponse, error)
	grpc.ClientStream
}

type textToSpeechServiceStreamTextToSpeechRequestClient struct {
	grpc.ClientStream
}

func (x *textToSpeechServiceStreamTextToSpeechRequestClient) Send(m *TextChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *textToSpeechServiceStreamTextToSpeechRequestClient) CloseAndRecv() (*TextToSpeechResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TextToSpeechResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *textToSpeechServiceClient) StreamTextToSpeechBidirectional(ctx context.Context, opts ...grpc.CallOption) (TextToSpeechService_StreamTextToSpeechBidirectionalClient, error) {
	stream, err := c.cc.NewStream(ctx, &TextToSpeechService_ServiceDesc.Streams[2], "/voice.TextToSpeechService/StreamTextToSpeechBidirectional", opts...)
	if err != nil {
		return nil, err
	}
	x := &textToSpeechServiceStreamTextToSpeechBidirectionalClient{stream}
	return x, nil
}

type TextToSpeechService_StreamTextToSpeechBidirectionalClient interface {
	Send(*TextChunk) error
	Recv() (*AudioChunk, error)
	grpc.ClientStream
}

type textToSpeechServiceStreamTextToSpeechBidirectionalClient struct {
	grpc.ClientStream
}

func (x *textToSpeechServiceStreamTextToSpeechBidirectionalClient) Send(m *TextChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *textToSpeechServiceStreamTextToSpeechBidirectionalClient) Recv() (*AudioChunk, error) {
	m := new(AudioChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TextToSpeechServiceServer is the server API for TextToSpeechService service.
// All implementations must embed UnimplementedTextToSpeechServiceServer
// for forward compatibility
type TextToSpeechServiceServer interface {
	// Simple: Text in, Audio out
	ConvertTextToSpeech(context.Context, *TextToSpeechRequest) (*TextToSpeechResponse, error)
	// Stream response: Long text in, stream of audio chunks out
	StreamTextToSpeech(*TextToSpeechRequest, TextToSpeechService_StreamTextToSpeechServer) error
	// Stream request: Stream of text chunks in, complete audio out
	StreamTextToSpeechRequest(TextToSpeechService_StreamTextToSpeechRequestServer) error
	// Bidirectional: Stream of text chunks in, stream of audio chunks out
	StreamTextToSpeechBidirectional(TextToSpeechService_StreamTextToSpeechBidirectionalServer) error
	mustEmbedUnimplementedTextToSpeechServiceServer()
}

// UnimplementedTextToSpeechServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTextToSpeechServiceServer struct {
}

func (UnimplementedTextToSpeechServiceServer) ConvertTextToSpeech(context.Context, *TextToSpeechRequest) (*TextToSpeechResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertTextToSpeech not implemented")
}
func (UnimplementedTextToSpeechServiceServer) StreamTextToSpeech(*TextToSpeechRequest, TextToSpeechService_StreamTextToSpeechServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTextToSpeech not implemented")
}
func (UnimplementedTextToSpeechServiceServer) StreamTextToSpeechRequest(TextToSpeechService_StreamTextToSpeechRequestServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTextToSpeechRequest not implemented")
}
func (UnimplementedTextToSpeechServiceServer) StreamTextToSpeechBidirectional(TextToSpeechService_StreamTextToSpeechBidirectionalServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTextToSpeechBidirectional not implemented")
}
func (UnimplementedTextToSpeechServiceServer) mustEmbedUnimplementedTextToSpeechServiceServer() {}

// UnsafeTextToSpeechServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TextToSpeechServiceServer will
// result in compilation errors.
type UnsafeTextToSpeechServiceServer interface {
	mustEmbedUnimplementedTextToSpeechServiceServer()
}

func RegisterTextToSpeechServiceServer(s grpc.ServiceRegistrar, srv TextToSpeechServiceServer) {
	s.RegisterService(&TextToSpeechService_ServiceDesc, srv)
}

func _TextToSpeechService_ConvertTextToSpeech_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextToSpeechRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TextToSpeechServiceServer).ConvertTextToSpeech(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/voice.TextToSpeechService/ConvertTextToSpeech",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TextToSpeechServiceServer).ConvertTextToSpeech(ctx, req.(*TextToSpeechRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TextToSpeechService_StreamTextToSpeech_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TextToSpeechRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TextToSpeechServiceServer).StreamTextToSpeech(m, &textToSpeechServiceStreamTextToSpeechServer{stream})
}

type TextToSpeechService_StreamTextToSpeechServer interface {
	Send(*AudioChunk) error
	grpc.ServerStream
}

type textToSpeechServiceStreamTextToSpeechServer struct {
	grpc.ServerStream
}

func (x *textToSpeechServiceStreamTextToSpeechServer) Send(m *AudioChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _TextToSpeechService_StreamTextToSpeechRequest_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TextToSpeechServiceServer).StreamTextToSpeechRequest(&textToSpeechServiceStreamTextToSpeechRequestServer{stream})
}

type TextToSpeechService_StreamTextToSpeechRequestServer interface {
	SendAndClose(*TextToSpeechResponse) error
	Recv() (*TextChunk, error)
	grpc.ServerStream
}

type textToSpeechServiceStreamTextToSpeechRequestServer struct {
	grpc.ServerStream
}

func (x *textToSpeechServiceStreamTextToSpeechRequestServer) SendAndClose(m *TextToSpeechResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *textToSpeechServiceStreamTextToSpeechRequestServer) Recv() (*TextChunk, error) {
	m := new(TextChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TextToSpeechService_StreamTextToSpeechBidirectional_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TextToSpeechServiceServer).StreamTextToSpeechBidirectional(&textToSpeechServiceStreamTextToSpeechBidirectionalServer{stream})
}

type TextToSpeechService_StreamTextToSpeechBidirectionalServer interface {
	Send(*AudioChunk) error
	Recv() (*TextChunk, error)
	grpc.ServerStream
}

type textToSpeechServiceStreamTextToSpeechBidirectionalServer struct {
	grpc.ServerStream
}

func (x *textToSpeechServiceStreamTextToSpeechBidirectionalServer) Send(m *AudioChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *textToSpeechServiceStreamTextToSpeechBidirectionalServer) Recv() (*TextChunk, error) {
	m := new(TextChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TextToSpeechService_ServiceDesc is the grpc.ServiceDesc for TextToSpeechService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TextToSpeechService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "voice.TextToSpeechService",
	HandlerType: (*TextToSpeechServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConvertTextToSpeech",
			Handler:    _TextToSpeechService_ConvertTextToSpeech_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamTextToSpeech",
			Handler:       _TextToSpeechService_StreamTextToSpeech_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTextToSpeechRequest",
			Handler:       _TextToSpeechService_StreamTextToSpeechRequest_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamTextToSpeechBidirectional",
			Handler:       _TextToSpeechService_StreamTextToSpeechBidirectional_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/voice.proto",
}

// SpeechToTextServiceClient is the client API for SpeechToTextService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SpeechToTextServiceClient interface {
	// Simple: Audio in, Text out
	ConvertSpeechToText(ctx context.Context, in *SpeechToTextRequest, opts ...grpc.CallOption) (*SpeechToTextResponse, error)
	// Stream response: Complete audio in, stream of text chunks out
	StreamSpeechToText(ctx context.Context, in *SpeechToTextRequest, opts ...grpc.CallOption) (SpeechToTextService_StreamSpeechToTextClient, error)
	// Stream request: Stream of audio chunks in, complete text out
	StreamSpeechToTextRequest(ctx context.Context, opts ...grpc.CallOption) (SpeechToTextService_StreamSpeechToTextRequestClient, error)
	// Bidirectional: Stream of audio chunks in, stream of text chunks out
	StreamSpeechToTextBidirectional(ctx context.Context, opts ...grpc.CallOption) (SpeechToTextService_StreamSpeechToTextBidirectionalClient, error)
}

type speechToTextServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSpeechToTextServiceClient(cc grpc.ClientConnInterface) SpeechToTextServiceClient {
	return &speechToTextServiceClient{cc}
}

func (c *speechToTextServiceClient) ConvertSpeechToText(ctx context.Context, in *SpeechToTextRequest, opts ...grpc.CallOption) (*SpeechToTextResponse, error) {
	out := new(SpeechToTextResponse)
	err := c.cc.Invoke(ctx, "/voice.SpeechToTextService/ConvertSpeechToText", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechToTextServiceClient) StreamSpeechToText(ctx context.Context, in *SpeechToTextRequest, opts ...grpc.CallOption) (SpeechToTextService_StreamSpeechToTextClient, error) {
	stream, err := c.cc.NewStream(ctx, &SpeechToTextService_ServiceDesc.Streams[0], "/voice.SpeechToTextService/StreamSpeechToText", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechToTextServiceStreamSpeechToTextClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SpeechToTextService_StreamSpeechToTextClient interface {
	Recv() (*TranscriptionChunk, error)
	grpc.ClientStream
}

type speechToTextServiceStreamSpeechToTextClient struct {
	grpc.ClientStream
}

func (x *speechToTextServiceStreamSpeechToTextClient) Recv() (*TranscriptionChunk, error) {
	m := new(TranscriptionChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechToTextServiceClient) StreamSpeechToTextRequest(ctx context.Context, opts ...grpc.CallOption) (SpeechToTextService_StreamSpeechToTextRequestClient, error) {
	stream, err := c.cc.NewStream(ctx, &SpeechToTextService_ServiceDesc.Streams[1], "/voice.SpeechToTextService/StreamSpeechToTextRequest", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechToTextServiceStreamSpeechToTextRequestClient{stream}
	return x, nil
}

type SpeechToTextService_StreamSpeechToTextRequestClient interface {
	Send(*AudioChunk) error
	CloseAndRecv() (*SpeechToTextResponse, error)
	grpc.ClientStream
}

type speechToTextServiceStreamSpeechToTextRequestClient struct {
	grpc.ClientStream
}

func (x *speechToTextServiceStreamSpeechToTextRequestClient) Send(m *AudioChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechToTextServiceStreamSpeechToTextRequestClient) CloseAndRecv() (*SpeechToTextResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SpeechToTextResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechToTextServiceClient) StreamSpeechToTextBidirectional(ctx context.Context, opts ...grpc.CallOption) (SpeechToTextService_StreamSpeechToTextBidirectionalClient, error) {
	stream, err := c.cc.NewStream(ctx, &SpeechToTextService_ServiceDesc.Streams[2], "/voice.SpeechToTextService/StreamSpeechToTextBidirectional", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechToTextServiceStreamSpeechToTextBidirectionalClient{stream}
	return x, nil
}

type SpeechToTextService_StreamSpeechToTextBidirectionalClient interface {
	Send(*AudioChunk) error
	Recv() (*TranscriptionChunk, error)
	grpc.ClientStream
}

type speechToTextServiceStreamSpeechToTextBidirectionalClient struct {
	grpc.ClientStream
}

func (x *speechToTextServiceStreamSpeechToTextBidirectionalClient) Send(m *AudioChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechToTextServiceStreamSpeechToTextBidirectionalClient) Recv() (*TranscriptionChunk, error) {
	m := new(TranscriptionChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SpeechToTextServiceServer is the server API for SpeechToTextService service.
// All implementations must embed UnimplementedSpeechToTextServiceServer
// for forward compatibility
type SpeechToTextServiceServer interface {
	// Simple: Audio in, Text out
	ConvertSpeechToText(context.Context, *SpeechToTextRequest) (*SpeechToTextResponse, error)
	// Stream response: Complete audio in, stream of text chunks out
	StreamSpeechToText(*SpeechToTextRequest, SpeechToTextService_StreamSpeechToTextServer) error
	// Stream request: Stream of audio chunks in, complete text out
	StreamSpeechToTextRequest(SpeechToTextService_StreamSpeechToTextRequestServer) error
	// Bidirectional: Stream of audio chunks in, stream of text chunks out
	StreamSpeechToTextBidirectional(SpeechToTextService_StreamSpeechToTextBidirectionalServer) error
	mustEmbedUnimplementedSpeechToTextServiceServer()
}

// UnimplementedSpeechToTextServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSpeechToTextServiceServer struct {
}

func (UnimplementedSpeechToTextServiceServer) ConvertSpeechToText(context.Context, *SpeechToTextRequest) (*SpeechToTextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertSpeechToText not implemented")
}
func (UnimplementedSpeechToTextServiceServer) StreamSpeechToText(*SpeechToTextRequest, SpeechToTextService_StreamSpeechToTextServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSpeechToText not implemented")
}
func (UnimplementedSpeechToTextServiceServer) StreamSpeechToTextRequest(SpeechToTextService_StreamSpeechToTextRequestServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSpeechToTextRequest not implemented")
}
func (UnimplementedSpeechToTextServiceServer) StreamSpeechToTextBidirectional(SpeechToTextService_StreamSpeechToTextBidirectionalServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSpeechToTextBidirectional not implemented")
}
func (UnimplementedSpeechToTextServiceServer) mustEmbedUnimplementedSpeechToTextServiceServer() {}

// UnsafeSpeechToTextServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SpeechToTextServiceServer will
// result in compilation errors.
type UnsafeSpeechToTextServiceServer interface {
	mustEmbedUnimplementedSpeechToTextServiceServer()
}

func RegisterSpeechToTextServiceServer(s grpc.ServiceRegistrar, srv SpeechToTextServiceServer) {
	s.RegisterService(&SpeechToTextService_ServiceDesc, srv)
}

func _SpeechToTextService_ConvertSpeechToText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpeechToTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechToTextServiceServer).ConvertSpeechToText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/voice.SpeechToTextService/ConvertSpeechToText",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechToTextServiceServer).ConvertSpeechToText(ctx, req.(*SpeechToTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechToTextService_StreamSpeechToText_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SpeechToTextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpeechToTextServiceServer).StreamSpeechToText(m, &speechToTextServiceStreamSpeechToTextServer{stream})
}

type SpeechToTextService_StreamSpeechToTextServer interface {
	Send(*TranscriptionChunk) error
	grpc.ServerStream
}

type speechToTextServiceStreamSpeechToTextServer struct {
	grpc.ServerStream
}

func (x *speechToTextServiceStreamSpeechToTextServer) Send(m *TranscriptionChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _SpeechToTextService_StreamSpeechToTextRequest_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechToTextServiceServer).StreamSpeechToTextRequest(&speechToTextServiceStreamSpeechToTextRequestServer{stream})
}

type SpeechToTextService_StreamSpeechToTextRequestServer interface {
	SendAndClose(*SpeechToTextResponse) error
	Recv() (*AudioChunk, error)
	grpc.ServerStream
}

type speechToTextServiceStreamSpeechToTextRequestServer struct {
	grpc.ServerStream
}

func (x *speechToTextServiceStreamSpeechToTextRequestServer) SendAndClose(m *SpeechToTextResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechToTextServiceStreamSpeechToTextRequestServer) Recv() (*AudioChunk, error) {
	m := new(AudioChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SpeechToTextService_StreamSpeechToTextBidirectional_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechToTextServiceServer).StreamSpeechToTextBidirectional(&speechToTextServiceStreamSpeechToTextBidirectionalServer{stream})
}

type SpeechToTextService_StreamSpeechToTextBidirectionalServer interface {
	Send(*TranscriptionChunk) error
	Recv() (*AudioChunk, error)
	grpc.ServerStream
}

type speechToTextServiceStreamSpeechToTextBidirectionalServer struct {
	grpc.ServerStream
}

func (x *speechToTextServiceStreamSpeechToTextBidirectionalServer) Send(m *TranscriptionChunk) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechToTextServiceStreamSpeechToTextBidirectionalServer) Recv() (*AudioChunk, error) {
	m := new(AudioChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SpeechToTextService_ServiceDesc is the grpc.ServiceDesc for SpeechToTextService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SpeechToTextService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "voice.SpeechToTextService",
	HandlerType: (*SpeechToTextServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConvertSpeechToText",
			Handler:    _SpeechToTextService_ConvertSpeechToText_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSpeechToText",
			Handler:       _SpeechToTextService_StreamSpeechToText_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSpeechToTextRequest",
			Handler:       _SpeechToTextService_StreamSpeechToTextRequest_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamSpeechToTextBidirectional",
			Handler:       _SpeechToTextService_StreamSpeechToTextBidirectional_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/voice.proto",
}
